<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cleaning Concierge Chat</title>
    <style>
      :root {
        color-scheme: light;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      }
      body {
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: radial-gradient(circle at top, #eff6ff, #f8fafc 60%);
      }
      .widget {
        width: 360px;
        height: 600px;
        background: #ffffff;
        box-shadow: 0 20px 45px rgba(15, 23, 42, 0.12);
        border-radius: 18px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .header {
        padding: 18px;
        background: linear-gradient(135deg, #2563eb, #1d4ed8);
        color: #ffffff;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      }
      .header h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
      }
      .header p {
        margin: 4px 0 0;
        font-size: 0.85rem;
        opacity: 0.85;
      }
      .quick-replies {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        padding: 12px 18px;
        background: #f8fafc;
        border-bottom: 1px solid #e2e8f0;
      }
      .quick-reply {
        padding: 8px 14px;
        border-radius: 999px;
        border: 1px solid #cbd5f5;
        background: #ffffff;
        color: #1d4ed8;
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .quick-reply:hover {
        background: #1d4ed8;
        color: #ffffff;
        border-color: #1d4ed8;
      }
      .messages {
        flex: 1;
        padding: 18px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        background: #f8fafc;
      }
      .bubble {
        max-width: 75%;
        border-radius: 16px;
        padding: 12px 14px;
        line-height: 1.4;
        font-size: 0.95rem;
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
        animation: fadeIn 0.2s ease;
      }
      .bubble.user {
        align-self: flex-end;
        background: #2563eb;
        color: #ffffff;
        border-bottom-right-radius: 4px;
      }
      .bubble.bot {
        align-self: flex-start;
        background: #ffffff;
        color: #0f172a;
        border-bottom-left-radius: 4px;
      }
      .input-area {
        padding: 14px 18px;
        border-top: 1px solid #e2e8f0;
        background: #ffffff;
        display: flex;
        gap: 10px;
      }
      .input-area input {
        flex: 1;
        padding: 12px 16px;
        border: 1px solid #cbd5f5;
        border-radius: 999px;
        outline: none;
        transition: border-color 0.2s ease;
      }
      .input-area input:focus {
        border-color: #2563eb;
      }
      .input-area button {
        padding: 12px 18px;
        border: none;
        border-radius: 999px;
        background: #2563eb;
        color: #ffffff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .input-area button:hover {
        background: #1d4ed8;
      }
      .loader {
        width: 24px;
        height: 24px;
        border: 3px solid rgba(37, 99, 235, 0.2);
        border-top-color: #2563eb;
        border-radius: 50%;
        animation: spin 0.7s linear infinite;
        align-self: center;
      }
      .card {
        background: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 14px;
        padding: 14px;
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.1);
        display: flex;
        flex-direction: column;
        gap: 10px;
        animation: fadeInUp 0.25s ease;
      }
      .card h4 {
        margin: 0;
        color: #1e293b;
        font-size: 0.95rem;
      }
      .card ul {
        margin: 0;
        padding-left: 16px;
        color: #475569;
        font-size: 0.85rem;
      }
      .card .slots {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .card button {
        align-self: flex-start;
        padding: 8px 14px;
        border-radius: 999px;
        border: 1px solid #2563eb;
        background: #2563eb;
        color: #ffffff;
        cursor: pointer;
      }
      .card button.secondary {
        background: #ffffff;
        color: #2563eb;
      }
      .quote-form,
      .availability-form {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .quote-form .form-grid,
      .availability-form .form-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }
      .quote-form label,
      .availability-form label {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 0.8rem;
        color: #334155;
      }
      .quote-form input,
      .quote-form select,
      .availability-form input,
      .availability-form select {
        padding: 8px 10px;
        border: 1px solid #cbd5f5;
        border-radius: 8px;
        font-size: 0.85rem;
      }
      .quote-form input:focus,
      .quote-form select:focus,
      .availability-form input:focus,
      .availability-form select:focus {
        outline: none;
        border-color: #2563eb;
      }
      .quote-form fieldset {
        border: 1px solid #e2e8f0;
        border-radius: 10px;
        padding: 10px 12px;
      }
      .quote-form fieldset legend {
        padding: 0 6px;
        font-size: 0.8rem;
        font-weight: 600;
        color: #1d4ed8;
      }
      .quote-form .extras-grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 8px;
      }
      .quote-form .extras-grid label {
        flex-direction: row;
        align-items: center;
        gap: 8px;
      }
      .quote-form .extras-grid input[type='number'] {
        width: 100%;
      }
      .quote-form button[type='submit'],
      .availability-form button[type='submit'] {
        align-self: stretch;
        font-weight: 600;
      }
      .quote-form .form-error,
      .availability-form .form-error {
        color: #ef4444;
        font-size: 0.8rem;
      }
      .quote-form .form-error[hidden],
      .availability-form .form-error[hidden] {
        display: none;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="widget">
      <div class="header">
        <h2>Cleaning Concierge</h2>
        <p>Here to help with quotes, bookings, and more.</p>
      </div>
      <div class="quick-replies" id="quickReplies">
        <button class="quick-reply" data-action="quote" data-text="Can I get a cleaning quote?">Get a Quote</button>
        <button class="quick-reply" data-action="availability" data-text="I would like to book a cleaning time.">Book a Time</button>
        <button class="quick-reply" data-text="Please walk me through your pricing.">Pricing</button>
        <button class="quick-reply" data-text="Share your policies with me.">Policies</button>
        <button class="quick-reply" data-action="human" data-text="I’d like to speak with a person.">Talk to an Agent</button>
      </div>
      <div class="messages" id="messages"></div>
      <div class="input-area">
        <input id="input" type="text" placeholder="Type a message..." autocomplete="off" />
        <button id="send" type="button">Send</button>
      </div>
    </div>
    <script>
      const messagesEl = document.getElementById('messages');
      const inputEl = document.getElementById('input');
      const sendBtn = document.getElementById('send');
      const quickRepliesEl = document.getElementById('quickReplies');

      const sessionMessages = [];
      let lastQuoteResult = null;
      let quoteFormCard = null;
      let availabilityFormCard = null;
      let lastAvailabilityResult = null;
      let lastBookingRecord = null;
      let paymentPromptCard = null;
      let lastPaymentLink = null;
      const DEFAULT_AVAILABILITY_DURATION = 2;

      function scrollToBottom() {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function escapeHtml(value) {
        return String(value).replace(/[&<>"']/g, (char) => {
          switch (char) {
            case '&':
              return '&amp;';
            case '<':
              return '&lt;';
            case '>':
              return '&gt;';
            case '"':
              return '&quot;';
            case "'":
              return '&#39;';
            default:
              return char;
          }
        });
      }

      function createBubble(text, role = 'bot') {
        const bubble = document.createElement('div');
        bubble.className = `bubble ${role}`;
        if (role === 'user') {
          bubble.textContent = text;
        } else {
          bubble.innerHTML = text;
        }
        messagesEl.appendChild(bubble);
        scrollToBottom();
        return bubble;
      }

      function createCard(html) {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = html;
        messagesEl.appendChild(card);
        scrollToBottom();
        return card;
      }

      function addUserMessage(text) {
        sessionMessages.push({ role: 'user', content: text });
        createBubble(text, 'user');
      }

      function addAssistantMessage(text) {
        sessionMessages.push({ role: 'assistant', content: text });
        createBubble(text, 'bot');
      }

      function showLoader() {
        const spinner = document.createElement('div');
        spinner.className = 'loader';
        messagesEl.appendChild(spinner);
        scrollToBottom();
        return () => {
          if (spinner.isConnected) {
            spinner.remove();
          }
        };
      }

      function formatCurrency(currency, amount) {
        return `${currency} ${amount.toFixed(2)}`;
      }

      function needsQuoteFlow(text) {
        const normalized = text.toLowerCase();
        return /\bquote\b|\bestimate\b/.test(normalized);
      }

      function needsAvailabilityFlow(text) {
        const normalized = text.toLowerCase();
        return /\b(book|schedule|availability|time slot|appointment)\b/.test(normalized);
      }

      function showQuoteForm() {
        if (quoteFormCard?.isConnected) {
          quoteFormCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          return;
        }

        const previous = lastQuoteResult?.request;

        const formMarkup = `
          <form class="quote-form">
            <div class="form-grid">
              <label>
                Rooms
                <input type="number" name="rooms" min="0" max="20" value="${previous?.rooms ?? 2}" required />
              </label>
              <label>
                Bathrooms
                <input type="number" name="baths" min="0" max="10" value="${previous?.baths ?? 1}" required />
              </label>
              <label>
                Square meters
                <input type="number" name="squareMeters" min="1" max="1000" value="${previous?.squareMeters ?? 80}" required />
              </label>
              <label>
                Service type
                <select name="serviceType">
                  <option value="standard" ${previous?.serviceType === 'standard' ? 'selected' : ''}>Standard</option>
                  <option value="deep" ${previous?.serviceType === 'deep' ? 'selected' : ''}>Deep clean</option>
                </select>
              </label>
              <label>
                Frequency
                <select name="frequency">
                  <option value="one_time" ${previous?.frequency === 'one_time' ? 'selected' : ''}>One-time</option>
                  <option value="weekly" ${previous?.frequency === 'weekly' ? 'selected' : ''}>Weekly</option>
                  <option value="biweekly" ${previous?.frequency === 'biweekly' ? 'selected' : ''}>Biweekly</option>
                  <option value="monthly" ${previous?.frequency === 'monthly' ? 'selected' : ''}>Monthly</option>
                </select>
              </label>
            </div>
            <fieldset>
              <legend>Extras</legend>
              <div class="extras-grid">
                <label>
                  <input type="checkbox" name="extraOven" ${previous?.extras?.insideOven ? 'checked' : ''} />
                  Inside oven
                </label>
                <label>
                  <input type="checkbox" name="extraFridge" ${previous?.extras?.insideFridge ? 'checked' : ''} />
                  Inside fridge
                </label>
                <label>
                  Windows (count)
                  <input type="number" min="0" max="100" name="extraWindows" value="${previous?.extras?.windows ?? 0}" />
                </label>
              </div>
            </fieldset>
            <div class="form-error" hidden></div>
            <button type="submit">Calculate quote</button>
          </form>
        `;

        quoteFormCard = createCard(formMarkup);
        const form = quoteFormCard.querySelector('form');
        const submitBtn = form.querySelector('button[type="submit"]');
        const errorEl = form.querySelector('.form-error');

        form.addEventListener('submit', async (event) => {
          event.preventDefault();
          errorEl.hidden = true;
          errorEl.textContent = '';

          const formData = new FormData(form);
          const rooms = Number(formData.get('rooms'));
          const baths = Number(formData.get('baths'));
          const squareMeters = Number(formData.get('squareMeters'));
          const serviceType = String(formData.get('serviceType') || 'standard');
          const frequency = String(formData.get('frequency') || 'one_time');

          if ([rooms, baths, squareMeters].some((value) => Number.isNaN(value) || value < 0)) {
            errorEl.textContent = 'Please enter valid non-negative numbers.';
            errorEl.hidden = false;
            return;
          }
          if (squareMeters <= 0) {
            errorEl.textContent = 'Square meters must be greater than zero.';
            errorEl.hidden = false;
            return;
          }
          if (rooms > 20 || baths > 10 || squareMeters > 1000) {
            errorEl.textContent = 'Keep rooms ≤ 20, baths ≤ 10, and square meters ≤ 1000.';
            errorEl.hidden = false;
            return;
          }

          const extras = {};
          if (formData.get('extraOven')) {
            extras.insideOven = true;
          }
          if (formData.get('extraFridge')) {
            extras.insideFridge = true;
          }
          const windowsCount = Number(formData.get('extraWindows'));
          if (Number.isNaN(windowsCount) || windowsCount < 0) {
            errorEl.textContent = 'Window count must be zero or greater.';
            errorEl.hidden = false;
            return;
          }
          if (windowsCount > 100) {
            errorEl.textContent = 'Please limit window count to 100 or fewer.';
            errorEl.hidden = false;
            return;
          }
          if (windowsCount > 0) {
            extras.windows = windowsCount;
          }

          const payload = {
            rooms,
            baths,
            squareMeters,
            serviceType,
            frequency,
            extras: Object.keys(extras).length ? extras : undefined,
          };

          const originalText = submitBtn.textContent;
          submitBtn.disabled = true;
          submitBtn.textContent = 'Calculating...';

          try {
            const response = await fetch('/tools/quote', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
            }

            const result = await response.json();
            if (!result?.data) {
              throw new Error('Malformed quote response');
            }

            lastQuoteResult = {
              request: payload,
              response: result.data,
            };
            window.lastQuoteResult = lastQuoteResult;

            appendToolResponses('quote_cleaning', { result: result.data });

            const friendlyFrequency = payload.frequency.replace('_', ' ');
            const tone = payload.serviceType === 'deep' ? 'deep clean' : 'standard clean';
            addAssistantMessage(
              `Your ${tone} (${friendlyFrequency}) comes to ${formatCurrency(
                result.data.currency,
                result.data.total,
              )}. Ready to pick a time?`,
            );
          } catch (error) {
            console.error('Quote calculation failed', error);
            errorEl.textContent = 'Unable to calculate the quote right now. Please double-check the details or try again.';
            errorEl.hidden = false;
          } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
          }
        });
      }

      function showAvailabilityForm() {
        const today = new Date().toISOString().split('T')[0];
        if (availabilityFormCard?.isConnected) {
          availabilityFormCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          return;
        }

        const previous = lastAvailabilityResult?.request;
        const initialDate = previous?.date ?? today;
        const initialDuration = previous?.durationHours ?? DEFAULT_AVAILABILITY_DURATION;

        const durationOptions = [2, 3, 4]
          .map((value) => {
            const selected = Number(initialDuration) === value ? 'selected' : '';
            return `<option value="${value}" ${selected}>${value} hours</option>`;
          })
          .join('');

        const formMarkup = `
          <form class="quote-form availability-form">
            <div class="form-grid">
              <label>
                Preferred date
                <input type="date" name="date" min="${today}" value="${initialDate}" required />
              </label>
              <label>
                Duration
                <select name="durationHours">
                  ${durationOptions}
                </select>
              </label>
            </div>
            <div class="form-error" hidden></div>
            <button type="submit">Check availability</button>
          </form>
        `;

        availabilityFormCard = createCard(formMarkup);
        const form = availabilityFormCard.querySelector('form');
        const submitBtn = form.querySelector('button[type="submit"]');
        const errorEl = form.querySelector('.form-error');

        form.addEventListener('submit', async (event) => {
          event.preventDefault();
          errorEl.hidden = true;
          errorEl.textContent = '';

          const formData = new FormData(form);
          const date = String(formData.get('date') || '').trim();
          const durationHours = Number(formData.get('durationHours') || DEFAULT_AVAILABILITY_DURATION);

          if (!date) {
            errorEl.textContent = 'Pick a date to check availability.';
            errorEl.hidden = false;
            return;
          }

          const payload = {
            date,
            durationHours,
          };

          const originalText = submitBtn.textContent;
          submitBtn.disabled = true;
          submitBtn.textContent = 'Checking...';

          try {
            const response = await fetch('/tools/availability', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const result = await response.json();
            if (!result?.data?.slots) {
              throw new Error('Malformed availability response');
            }

            lastAvailabilityResult = {
              request: payload,
              slots: result.data.slots,
              durationHours: result.data.durationHours ?? payload.durationHours,
            };
            window.lastAvailabilityResult = lastAvailabilityResult;

            appendToolResponses('check_availability', { slots: result.data.slots });
            addAssistantMessage('Here are the closest openings—tap one that works for you.');
          } catch (error) {
            console.error('Availability lookup failed', error);
            errorEl.textContent = 'Unable to fetch availability right now. Please try another date or refresh later.';
            errorEl.hidden = false;
          } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
          }
        });
      }

      function showPaymentPrompt(booking) {
        const currency = booking?.quote?.currency ?? lastQuoteResult?.response?.currency ?? 'USD';
        const amount = booking?.quote?.total ?? lastQuoteResult?.response?.total ?? 0;
        if (!booking?.id || !Number.isFinite(amount)) {
          return;
        }

        if (paymentPromptCard?.isConnected) {
          paymentPromptCard.remove();
        }

        const markup = `
          <div class="payment-prompt">
            <h4>Ready for payment?</h4>
            <p>Total due: <strong>${formatCurrency(currency, amount)}</strong></p>
            <button data-action="generate-payment">Generate payment link</button>
            <div class="form-error" data-role="payment-error" hidden></div>
          </div>
        `;

        paymentPromptCard = createCard(markup);
        const actionBtn = paymentPromptCard.querySelector('button[data-action="generate-payment"]');
        const errorEl = paymentPromptCard.querySelector('[data-role="payment-error"]');

        actionBtn.addEventListener('click', async () => {
          if (!lastBookingRecord?.id) {
            errorEl.textContent = 'No booking found. Please create a booking first.';
            errorEl.hidden = false;
            return;
          }

          errorEl.hidden = true;
          errorEl.textContent = '';

          const originalText = actionBtn.textContent;
          actionBtn.disabled = true;
          actionBtn.textContent = 'Generating...';

          try {
            const response = await fetch('/tools/payment-link', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                bookingId: lastBookingRecord.id,
                amount: lastBookingRecord.quote.total,
                currency: lastBookingRecord.quote.currency,
              }),
            });

            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }

            const result = await response.json();
            if (!result?.data) {
              throw new Error('Malformed payment link response');
            }

            lastPaymentLink = result.data;
            window.lastPaymentLink = lastPaymentLink;
            appendToolResponses('generate_payment_link', { paymentLink: result.data });
            addAssistantMessage('Here’s a secure payment link whenever you’re ready.');
            paymentPromptCard.remove();
            paymentPromptCard = null;
          } catch (error) {
            console.error('Payment link generation failed', error);
            errorEl.textContent = 'Unable to generate the payment link right now. Please try again shortly.';
            errorEl.hidden = false;
          } finally {
            actionBtn.disabled = false;
            actionBtn.textContent = originalText;
          }
        });
      }

      function appendToolResponses(toolName, rawResults) {
        if (!rawResults) return;
        const results = Array.isArray(rawResults) ? rawResults : [rawResults];
        results.forEach((entry) => {
          switch (toolName) {
            case 'quote_cleaning': {
              const result = entry?.result;
              if (!result) return;
              if (lastQuoteResult?.request) {
                lastQuoteResult = { ...lastQuoteResult, response: result };
              } else {
                lastQuoteResult = { response: result };
              }
              window.lastQuoteResult = lastQuoteResult;
              const { currency, total, breakdown } = result;
              const extrasTotal =
                breakdown.extras.insideOven + breakdown.extras.insideFridge + breakdown.extras.windows;
              const breakdownItems = [
                ['Base visit', formatCurrency(currency, breakdown.baseVisitFee)],
                ['Rooms', formatCurrency(currency, breakdown.rooms)],
                ['Baths', formatCurrency(currency, breakdown.baths)],
                ['Square meters', formatCurrency(currency, breakdown.squareMeters)],
              ];
              if (extrasTotal > 0) {
                breakdownItems.push(['Extras', formatCurrency(currency, extrasTotal)]);
              }
              breakdownItems.push(['Service type multiplier', `x${breakdown.serviceMultiplier.toFixed(2)}`]);
              breakdownItems.push(['Frequency multiplier', `x${breakdown.frequencyMultiplier.toFixed(2)}`]);
              const listMarkup = breakdownItems
                .map(([label, value]) => `<li><strong>${label}:</strong> ${value}</li>`)
                .join('');
              createCard(
                `<h4>Quote Breakdown</h4>
                <div><strong>Total:</strong> ${formatCurrency(currency, total)}</div>
                <ul>${listMarkup}</ul>`,
              );
              break;
            }
            case 'check_availability': {
              const slots = entry?.slots ?? [];
              lastAvailabilityResult = {
                ...(lastAvailabilityResult ?? {}),
                slots,
              };
              window.lastAvailabilityResult = lastAvailabilityResult;
              if (!slots.length) {
                createCard('<h4>Available Times</h4><p>No availability found for that date.</p>');
                return;
              }
              const buttons = slots
                .slice(0, 6)
                .map(
                  (slot) =>
                    `<button class="secondary" data-start="${slot.start}" data-end="${slot.end}">${slot.label}</button>`,
                )
                .join('');
              const card = createCard(`<h4>Available Times</h4><div class="slots">${buttons}</div>`);
              card.querySelectorAll('button[data-start]').forEach((button) => {
                button.addEventListener('click', () => {
                  const label = button.textContent || 'selected slot';
                  void sendMessageToServer(`Let's book the ${label} slot.`);
                });
              });
              break;
            }
            case 'create_booking': {
              const booking = entry?.booking;
              if (!booking) return;
              lastBookingRecord = booking;
              window.lastBookingRecord = lastBookingRecord;
              createCard(
                `<h4>Booking Confirmed</h4>
                <p>ID: <strong>${booking.id}</strong></p>
                <p>Status: ${booking.status}</p>
                <p>When: ${new Date(booking.scheduledStart).toLocaleString()} - ${new Date(
                  booking.scheduledEnd,
                ).toLocaleString()}</p>`,
              );
              showPaymentPrompt(booking);
              break;
            }
            case 'generate_payment_link': {
              const link = entry?.paymentLink;
              if (!link) return;
              lastPaymentLink = link;
              window.lastPaymentLink = lastPaymentLink;
              createCard(
                `<h4>Secure Payment</h4>
                <p>Total: ${formatCurrency(link.currency, link.amount)}</p>
                <button onclick="window.open('${link.url}', '_blank')">Pay now</button>`,
              );
              break;
            }
            case 'faq_lookup': {
              if (entry?.found === false) {
                createCard('<h4>No Match</h4><p>I could not find that in the cleaning guide.</p>');
                return;
              }
              if (!entry?.answer) return;
              const source = entry?.metadata?.sourceKey ? escapeHtml(entry.metadata.sourceKey) : 'knowledge base';
              createCard(
                `<h4>Answer</h4>
                <p>${escapeHtml(entry.answer)}</p>
                <p style="font-size:0.75rem;color:#64748b;">Source: ${source}</p>`,
              );
              break;
            }
            case 'save_lead': {
              const lead = entry?.lead;
              if (!lead) return;
              createCard(
                `<h4>We Saved Your Details</h4>
                <p>Thanks, ${lead.name}! Our team will reach out shortly.</p>`,
              );
              break;
            }
            default:
              break;
          }
        });
      }

      async function sendMessageToServer(text, options = { renderUser: true }) {
        const cleaned = text.trim();
        if (!cleaned) return;

        if (options.renderUser) {
          addUserMessage(cleaned);
        }
        inputEl.value = '';
        inputEl.focus();

        const dismissLoader = showLoader();

        try {
          const response = await fetch('/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: sessionMessages }),
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }

          const data = await response.json();
          dismissLoader();

          if (data.toolResults && typeof data.toolResults === 'object') {
            Object.entries(data.toolResults).forEach(([toolName, results]) => {
              appendToolResponses(toolName, results);
            });
          }

          if (data.message?.content) {
            addAssistantMessage(data.message.content);
          } else {
            addAssistantMessage('All set. Let me know if you need anything else!');
          }
        } catch (error) {
          dismissLoader();
          console.error('Failed to send message', error);
          createCard('<h4>Uh oh!</h4><p>Something went wrong. Please try again in a moment.</p>');
        }
      }

      function handleUserInput(rawText) {
        const text = rawText.trim();
        if (!text) return;

        if (needsQuoteFlow(text)) {
          addUserMessage(text);
          inputEl.value = '';
          if (!quoteFormCard?.isConnected) {
            addAssistantMessage("Happy to help! Let's grab a few details for your quote.");
          }
          showQuoteForm();
          return;
        }

        if (needsAvailabilityFlow(text)) {
          addUserMessage(text);
          inputEl.value = '';
          if (!availabilityFormCard?.isConnected) {
            addAssistantMessage('Sure thing! Which date should we check?');
          }
          showAvailabilityForm();
          return;
        }

        void sendMessageToServer(text);
      }

      sendBtn.addEventListener('click', () => {
        handleUserInput(inputEl.value);
      });

      inputEl.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && !event.shiftKey) {
          event.preventDefault();
          handleUserInput(inputEl.value);
        }
      });

      quickRepliesEl.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-text]');
        if (!button) return;
        if (button.dataset.action === 'quote') {
          handleUserInput(button.dataset.text || 'I need a cleaning quote.');
          return;
        }
        if (button.dataset.action === 'availability') {
          handleUserInput(button.dataset.text || 'I want to book a time.');
          return;
        }
        if (button.dataset.action === 'human') {
          void sendMessageToServer(button.dataset.text || 'I need to speak with a human agent.');
          return;
        }
        handleUserInput(button.dataset.text || '');
      });

      addAssistantMessage('Hi there! How can I help with your cleaning today?');
    </script>
  </body>
</html>
